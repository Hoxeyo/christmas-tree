<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Golden Christmas Interaction</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Times New Roman', serif; }
    


#info {
      position: absolute; top: 25px; width: 100%;
      text-align: center; color: #ffd700;
      font-size: 40px; font-weight: bold; letter-spacing: 3px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
      pointer-events: none; z-index: 10;
      opacity: 1; transition: opacity 2s;
    }
    #instruction {
      position: absolute; bottom: 25px; width: 100%;
      text-align: center; color: #ccaa00;
      font-size: 14px; pointer-events: none;
      opacity: 1; transition: opacity 2s;
      letter-spacing: 2px;
    }
  </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
</head>
<body>
  <div id="errhud"></div>
  <div id="loadhud">Loading 3D…</div>

</div>
  <div id="info">MERRY CHRISTMAS</div>
  <div id="instruction">CLICK ANYWHERE TO MORPH</div>
<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/environments/RoomEnvironment.js';

      const errhud = document.getElementById('errhud');
      const showErr = (msg) => {
        try{
          errhud.style.display = 'block';
          errhud.textContent = (errhud.textContent ? errhud.textContent + "\n\n" : "") + msg;
        }catch(e){}
      };
      window.addEventListener('error', (e) => showErr('JS Error: ' + (e.message || e.error || e.type)));
      window.addEventListener('unhandledrejection', (e) => showErr('Promise Rejection: ' + (e.reason?.message || e.reason || 'unknown')));
    

    let scene, camera, renderer, composer, controls;
    let topStar;

    const sphereMeshes = new Map(); // key -> InstancedMesh
    let cubeGoldMesh, cubeGreenMesh;
    const snowLayers = [];

    const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const particleCount = IS_MOBILE ? 4500 : 8500; // mobile-safe default
    const MAX_DPR = IS_MOBILE ? 1.5 : 2;
    const dummy = new THREE.Object3D();
    const particles = [];
    let currentState = 0;

    const clock = new THREE.Clock();
    let timeAcc = 0;

    const COLOR_GOLD  = new THREE.Color(0xD9B64B);
    const COLOR_RED   = new THREE.Color(0xA01228);
    const COLOR_GREEN = new THREE.Color(0x18A86E);

    init();
    animate();

    function init() {



      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x120a07, 0.015);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 48);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, MAX_DPR));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.98;
      document.body.appendChild(renderer.domElement);
      const loadhud = document.getElementById('loadhud');
      if (loadhud) loadhud.style.display = 'none';

      let pmrem;
      try {
        pmrem = new THREE.PMREMGenerator(renderer);
        scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
      } catch (e) {
        console.log('Environment setup skipped:', e);
      } finally {
        try { pmrem && pmrem.dispose(); } catch (e) {}
      }
controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.8;
      controls.enablePan = false;

      scene.add(new THREE.AmbientLight(0xffe2c8, 0.50));

      const mainLight = new THREE.PointLight(0xffb14a, 980, 130);
      mainLight.position.set(22, 32, 18);
      scene.add(mainLight);

      const fillLight = new THREE.PointLight(0xfff0d8, 420, 170);
      fillLight.position.set(-22, 18, 22);
      scene.add(fillLight);

      const bottomLight = new THREE.PointLight(0xff7a2a, 480, 105);
      bottomLight.position.set(0, -14, 0);
      scene.add(bottomLight);

      const sphereGeo = new THREE.SphereGeometry(0.20, 16, 16) // smaller spheres (denser);
      const cubeGeo = new THREE.BoxGeometry(0.26, 0.26, 0.26) // smaller cubes (denser);

      const glowTiers = {
        dim:    { emissiveIntensity: 0.08, clearcoat: 0.62, roughness: 0.26 },
        mid:    { emissiveIntensity: 0.14, clearcoat: 0.66, roughness: 0.24 },
        bright: { emissiveIntensity: 0.22, clearcoat: 0.70, roughness: 0.22 },
      };

      function makeSphereMat(colorName, tier) {
        const baseColor =
          (colorName === 'red') ? COLOR_RED :
          (colorName === 'green') ? COLOR_GREEN :
          COLOR_GOLD;

        const emissiveColor =
          (colorName === 'red') ? new THREE.Color(0x330008) :
          (colorName === 'green') ? new THREE.Color(0x001f12) :
          new THREE.Color(0x3a2500);

        const metalness = (colorName === 'gold') ? 1.0 : 0.88;

        return new THREE.MeshPhysicalMaterial({
          color: baseColor,
          metalness,
          roughness: tier.roughness,
          clearcoat: tier.clearcoat,
          clearcoatRoughness: 0.22,
          emissive: emissiveColor,
          emissiveIntensity: tier.emissiveIntensity,
          envMapIntensity: 1.55
        });
      }

      const cubeGoldMat = new THREE.MeshPhysicalMaterial({
        color: COLOR_GOLD,
        metalness: 1.0,
        roughness: 0.30,
        clearcoat: 0.62,
        clearcoatRoughness: 0.26,
        emissive: new THREE.Color(0x2a1a00),
        emissiveIntensity: 0.10,
        envMapIntensity: 1.45
      });

      const cubeGreenMat = new THREE.MeshPhysicalMaterial({
        color: COLOR_GREEN,
        metalness: 0.88,
        roughness: 0.30,
        clearcoat: 0.62,
        clearcoatRoughness: 0.26,
        emissive: new THREE.Color(0x001f12),
        emissiveIntensity: 0.10,
        envMapIntensity: 1.45
      });

      const treePositions = getTreePositions(particleCount);
      const textPositions = getTextPositions("Merry Christmas", particleCount);
      const explodePositions = getExplodePositions(particleCount);

      let treeTopY = -Infinity;
      for (let i = 0; i < treePositions.length; i++) treeTopY = Math.max(treeTopY, treePositions[i].y);

      let axisX = 0, axisZ = 0, axisCount = 0;
      const band = 0.9;
      for (let i = 0; i < treePositions.length; i++) {
        const p = treePositions[i];
        if (p.y > treeTopY - band) { axisX += p.x; axisZ += p.z; axisCount++; }
      }
      if (axisCount > 0) { axisX /= axisCount; axisZ /= axisCount; }

      // ===== 八面体：矮胖一点，且“略微比正方体细长” =====
      // 关键：增大 x/z，降低 y 的拉伸比例，让它不再“针状”，但仍稍微更高一点点
      const octSize = 0.78; // smaller to match denser ornaments
      const octGeo = new THREE.OctahedronGeometry(octSize, 0);

      // ✅ 你要的形状：矮胖 + 略微细长（y 比 xz 略大一点）
      octGeo.scale(1.25, 1.35, 1.25);

      // 底部对齐到 y=0，并把中心对齐 xz=0
      octGeo.computeBoundingBox();
      const bb = octGeo.boundingBox;
      const cx = (bb.min.x + bb.max.x) * 0.5;
      const cz = (bb.min.z + bb.max.z) * 0.5;
      const minY = bb.min.y;
      octGeo.translate(-cx, -minY, -cz);

      const octMat = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color(0xffd700),
        metalness: 1.0,
        roughness: 0.18,
        clearcoat: 0.70,
        clearcoatRoughness: 0.22,
        emissive: new THREE.Color(0x2a1a00),
        emissiveIntensity: 0.12,
        envMapIntensity: 1.55
      });

      topStar = new THREE.Mesh(octGeo, octMat);
      topStar.position.set(axisX, treeTopY, axisZ);
      topStar.rotation.set(0, 0, 0);
      scene.add(topStar);

      // ===== 粒子规划 =====
      function pickSphereColor() {
        const r = Math.random();
        // Increased GREEN proportion for a stronger Christmas palette
        if (r < 0.52) return 'gold';
        if (r < 0.74) return 'red';
        return 'green';
      }
      function pickGlowTier() {
        const r = Math.random();
        if (r < 0.50) return 'dim';
        if (r < 0.85) return 'mid';
        return 'bright';
      }

      const plan = new Array(particleCount);
      const counts = {};
      const localIndexMap = {};
      const inc = (k) => counts[k] = (counts[k] || 0) + 1;
      const nextIndex = (k) => (localIndexMap[k] = (localIndexMap[k] || 0) + 1) - 1;

      for (let i = 0; i < particleCount; i++) {
        const isCube = Math.random() > 0.60;
        if (!isCube) {
          const c = pickSphereColor();
          const tier = pickGlowTier();
          const key = `sphere:${c}:${tier}`;
          plan[i] = { group: key, isCube: false };
          inc(key);
        } else {
          const isGold = Math.random() < 0.55; // more green cubes
          const key = isGold ? 'cube:gold' : 'cube:green';
          plan[i] = { group: key, isCube: true };
          inc(key);
        }
      }

      function ensureSphereMesh(colorName, tierName) {
        const key = `sphere:${colorName}:${tierName}`;
        if (sphereMeshes.has(key)) return sphereMeshes.get(key);

        const mat = makeSphereMat(colorName, glowTiers[tierName]);
        const mesh = new THREE.InstancedMesh(sphereGeo, mat, Math.max(counts[key] || 0, 1));
        mesh.count = counts[key] || 0;
        sphereMeshes.set(key, mesh);
        scene.add(mesh);
        return mesh;
      }

      cubeGoldMesh = new THREE.InstancedMesh(cubeGeo, cubeGoldMat, Math.max(counts['cube:gold'] || 0, 1));
      cubeGreenMesh = new THREE.InstancedMesh(cubeGeo, cubeGreenMat, Math.max(counts['cube:green'] || 0, 1));
      cubeGoldMesh.count = counts['cube:gold'] || 0;
      cubeGreenMesh.count = counts['cube:green'] || 0;
      scene.add(cubeGoldMesh);
      scene.add(cubeGreenMesh);

      for (let i = 0; i < particleCount; i++) {
        const entry = plan[i];
        let meshRef;

        if (!entry.isCube) {
          const parts = entry.group.split(':');
          meshRef = ensureSphereMesh(parts[1], parts[2]);
        } else {
          meshRef = (entry.group === 'cube:gold') ? cubeGoldMesh : cubeGreenMesh;
        }

        const localIndex = nextIndex(entry.group);

        particles.push({
          idx: i,
          meshRef,
          localIndex,
          currentPos: new THREE.Vector3().copy(treePositions[i]),
          targets: { 0: treePositions[i], 1: explodePositions[i], 2: textPositions[i] }
        });
      }

      // ✅ 雪：更多、更快（保留你之前那一版）
      createSnowVolume();
      updateInstances();
      updateSnow(0);

      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.78,
        0.40,
        0.62
      );

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      window.addEventListener('resize', onWindowResize);
      window.addEventListener('mousedown', onMouseDown);
      window.addEventListener('touchstart', onTouchStart, { passive: false });
    }

    // ========== 雪 ==========
    function rand(min, max) { return min + Math.random() * (max - min); }

    function createSnowLayer({count, radius, speedMin, speedMax, opacity, areaX, areaZ, yMin, yMax}) {
      const geo = new THREE.SphereGeometry(radius, 8, 8);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.0,
        roughness: 0.95,
        transparent: true,
        opacity,
        depthWrite: false
      });

      const mesh = new THREE.InstancedMesh(geo, mat, count);
      mesh.frustumCulled = false;

      const layer = {
        mesh, count, areaX, areaZ, yMin, yMax,
        positions: new Array(count),
        speeds: new Float32Array(count),
        drifts: new Float32Array(count * 2),
        phases: new Float32Array(count),
        scales: new Float32Array(count),
      };

      for (let i = 0; i < count; i++) {
        layer.positions[i] = new THREE.Vector3(
          rand(-areaX, areaX),
          rand(yMin, yMax),
          rand(-areaZ, areaZ)
        );
        layer.speeds[i] = rand(speedMin, speedMax);
        layer.drifts[i * 2 + 0] = rand(-1.05, 1.05);
        layer.drifts[i * 2 + 1] = rand(-1.05, 1.05);
        layer.phases[i] = rand(0, Math.PI * 2);
        layer.scales[i] = rand(0.75, 1.85);
      }

      scene.add(mesh);
      snowLayers.push(layer);
    }

    function createSnowVolume() {
      // iOS Safari can stall if snow is too dense; use mobile-safe counts automatically.
      const snow1 = IS_MOBILE ? 4200 : 9000;
      const snow2 = IS_MOBILE ? 3100 : 6800;
      const snow3 = IS_MOBILE ? 2200 : 4600;
      const snow4 = IS_MOBILE ? 2000 : 5200;

      const yMinMain = IS_MOBILE ? -30 : -35;
      const yMaxMain = IS_MOBILE ? 78  : 85;

      createSnowLayer({
        count: snow1, radius: 0.045, speedMin: 1.8, speedMax: 3.6, opacity: 0.55,
        areaX: 120, areaZ: 120, yMin: yMinMain, yMax: yMaxMain
      });

      createSnowLayer({
        count: snow2, radius: 0.065, speedMin: 3.0, speedMax: 5.5, opacity: 0.75,
        areaX: 105, areaZ: 105, yMin: yMinMain, yMax: yMaxMain
      });

      createSnowLayer({
        count: snow3, radius: 0.095, speedMin: 4.5, speedMax: 8.0, opacity: 0.90,
        areaX: 90, areaZ: 90, yMin: yMinMain, yMax: yMaxMain
      });

      // Extra bottom-focused layer
      createSnowLayer({
        count: snow4, radius: 0.055, speedMin: 2.6, speedMax: 5.4, opacity: 0.72,
        areaX: 95, areaZ: 95, yMin: -55, yMax: 18
      });
    });

      createSnowLayer({
        count: 6800,
        radius: 0.065,
        speedMin: 3.0,
        speedMax: 5.5,
        opacity: 0.75,
        areaX: 105,
        areaZ: 105,
        yMin: -35,
        yMax: 85
      });

      createSnowLayer({
        count: 4600,
        radius: 0.095,
        speedMin: 4.5,
        speedMax: 8.0,
        opacity: 0.90,
        areaX: 90,
        areaZ: 90,
        yMin: -35,
        yMax: 85
      });

      // Extra bottom-focused layer
      createSnowLayer({
        count: 5200,
        radius: 0.055,
        speedMin: 2.6,
        speedMax: 5.4,
        opacity: 0.72,
        areaX: 95,
        areaZ: 95,
        yMin: -55,
        yMax: 18
      });
    }

    function updateSnow(dt) {
      const t = timeAcc;
      for (const layer of snowLayers) {
        const { mesh, count, areaX, areaZ, yMin, yMax, positions, speeds, drifts, phases, scales } = layer;

        for (let i = 0; i < count; i++) {
          const p = positions[i];
          p.y -= speeds[i] * dt;

          const dx = drifts[i * 2 + 0];
          const dz = drifts[i * 2 + 1];
          const sway = Math.sin(t * 1.8 + phases[i]) * 0.55;

          p.x += (dx * 0.75 + sway) * dt;
          p.z += (dz * 0.75 - sway * 0.55) * dt;

          if (p.x > areaX) p.x = -areaX;
          if (p.x < -areaX) p.x = areaX;
          if (p.z > areaZ) p.z = -areaZ;
          if (p.z < -areaZ) p.z = areaZ;

          if (p.y < yMin) {
            p.y = yMax + rand(0, 12);
            p.x = rand(-areaX, areaX);
            p.z = rand(-areaZ, areaZ);
          }

          dummy.position.copy(p);
          dummy.rotation.set(0, 0, 0);
          const s = scales[i];
          dummy.scale.set(s, s, s);
          dummy.updateMatrix();
          mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.instanceMatrix.needsUpdate = true;
      }
    }

    // ========== 树形位置 ==========
        function getTreePositions(count) {
      // More natural, scattered distribution (no obvious spiral/rings)
      // Strategy:
      // - Stratify by height (y) to keep a tree silhouette
      // - Random angle per particle
      // - Radius shrinks towards the top, with noise and slight bias to fill volume
      // - Add a small "trunk/core" cluster so it doesn't look hollow
      const pos = [];
      const height = 25;     // total tree height (matches previous)
      const yBase = -13;     // shifted down further      // base offset (matches previous)
      const maxR = 9;        // base radius (matches previous)
      const TWO_PI = Math.PI * 2;

      for (let i = 0; i < count; i++) {
        const p = i / count; // 0..1
        // Height: mostly stratified, but with jitter so it doesn't form bands
        let y = p * height + yBase;
        y += (Math.random() - 0.5) * 0.85; // break "layer" lines

        // Radius envelope: cone-like, a bit eased so it looks fuller
        const envelope = maxR * (1 - Math.pow(p, 0.72));

        // Random fill inside the envelope:
        // Use pow on random to bias distribution (slightly more towards surface)
        const u = Math.random();
        let r = envelope * Math.pow(u, 0.55);

        // Add extra thickness noise so it feels messy/organic
        r += (Math.random() - 0.5) * 0.9;

        // Occasionally pull points toward the core to avoid a hollow shell
        if (Math.random() < 0.12) {
          r *= 0.25 + Math.random() * 0.35; // trunk-ish cluster
        }

        // Angle: fully random (kills spiral/ring look)
        const a = Math.random() * TWO_PI;

        // Slight 3D wobble so it doesn't look too symmetric
        const wobble = (Math.random() - 0.5) * (0.25 + 0.65 * (1 - p));

        const x = Math.cos(a) * r + wobble;
        const z = Math.sin(a) * r - wobble;

        pos.push(new THREE.Vector3(x, y, z));
      }

      return pos;
    }

    function getExplodePositions(count) {
      const pos = [];
      for (let i = 0; i < count; i++) {
        const v = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
        v.normalize().multiplyScalar(10 + Math.random() * 30);
        pos.push(v);
      }
      return pos;
    }

    function getTextPositions(text, count) {
      const canvas = document.createElement('canvas');
      canvas.width = 500; canvas.height = 200;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, 500, 200);
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '900 56px "Times New Roman"'; // smaller text font
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText("MERRY", 250, 60);
      ctx.fillText("CHRISTMAS", 250, 130);

      const data = ctx.getImageData(0, 0, 500, 200).data;
      const validPoints = [];
      for (let y = 0; y < 200; y += 2) { // denser sampling
        for (let x = 0; x < 500; x += 2) { // denser sampling
          if (data[(y * 500 + x) * 4] > 100) {
            validPoints.push(new THREE.Vector3((x-250)*0.13, (100-y)*0.13+0, 0));
          }
        }
      }
      if (validPoints.length === 0) return getExplodePositions(count);

      const finalPos = [];
      for (let i = 0; i < count; i++) {
        const p = validPoints[i % validPoints.length];
        finalPos.push(new THREE.Vector3(p.x, p.y, p.z + (Math.random()-0.5)*0.8));
      }
      return finalPos;
    }

    // ========== 交互 ==========
    function onMouseDown(event) {
      if (event.target.id === 'start-btn' || event.target.id === 'overlay') return;
      const startX = event.clientX, startY = event.clientY, startTime = Date.now();
      const onMouseUp = (e) => {
        const diffTime = Date.now() - startTime;
        const dist = Math.sqrt((e.clientX - startX) ** 2 + (e.clientY - startY) ** 2);
        if (diffTime < 400 && dist < 20) switchState();
        window.removeEventListener('mouseup', onMouseUp);
      };
      window.addEventListener('mouseup', onMouseUp);
    }

    function onTouchStart(event) {
      if (event.target.id === 'start-btn' || event.target.id === 'overlay') return;
      switchState();
    }

    function switchState() {
      currentState = (currentState + 1) % 3;
      const dur = 1.5;

      if (currentState === 0) {
        gsap.to(topStar.scale, { x: 1, y: 1, z: 1, duration: 1.2, ease: "elastic.out(1, 0.5)" });
      } else {
        gsap.to(topStar.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 0.5 });
      }

      particles.forEach(p => {
        const target = p.targets[currentState];
        gsap.to(p.currentPos, {
          x: target.x, y: target.y, z: target.z,
          duration: dur + Math.random() * 0.5,
          ease: "power2.inOut"
        });
      });
    }

    function updateInstances() {
      const t = Date.now() * 0.001;

      if (topStar) {
        topStar.rotation.x = 0;
        topStar.rotation.z = 0;
        topStar.rotation.y = t * 0.6;
      }

      particles.forEach(p => {
        dummy.position.copy(p.currentPos);
        dummy.rotation.set(t + p.idx, t + p.idx, 0);
        if (currentState === 2) {
        // smaller geometry only in TEXT state (denser, higher-res look)
        dummy.scale.set(0.72, 0.72, 0.72);
      } else {
        dummy.scale.set(1, 1, 1);
      }
        dummy.updateMatrix();
        p.meshRef.setMatrixAt(p.localIndex, dummy.matrix);
      });

      for (const mesh of sphereMeshes.values()) mesh.instanceMatrix.needsUpdate = true;
      cubeGoldMesh.instanceMatrix.needsUpdate = true;
      cubeGreenMesh.instanceMatrix.needsUpdate = true;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      timeAcc += dt;

      controls.update();
      updateInstances();
      updateSnow(dt);
      composer.render();
    }
  </script>
</body>
</html>
